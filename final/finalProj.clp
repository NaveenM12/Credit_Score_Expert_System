/*
* @author Naveen Mirapuri
* created December 27, 2018
*  
* This program creates a credit score for a user through responses to a series of questions and then uses that credit score to 
* determine what type of loans the user can access.
* 
* The credit score will range from 0 to 100 and includes variables that are included in FICO scores as well as additional conditions.
*
* The values for each category were determined through interviews with Jody Bhagat who is an executive at an AI financial services
* firm and Manish Punjabi who works in data analytics at FICO. Additionally, many of the cutoff values for different category scores
* were generated by the comparative score/values from FICO credit scores. For example, if the top tier FICO scores had credit utilization
* ratios under 10% and recieved 30 year fixed mortgages with 4.127% apr, then those with similar credit utilization ratios would recieve
* high scores within this system as well and also have access to the same mortgages. 
* 
*/
(clear)
(reset)


(batch toolbox.clp)                                                            ; batches in the toolbox so ask function can be accessed




/*    
* Lines below backward chain the variables of the credit score that are to be included in calculating the credit score
*/


/*
* Credit utilization is how much a person spends relative to their credit limit and is indicative of their risk. Lower credit
* utilization is better because it means that it less likely for a person to overspend and be unable to payback lenders.
* There is a 30% rule when it comes to credit utilization that a person's utlization should stay under 30% to maintain good credit
*/
(do-backward-chaining creditUtilization)                              

/*
* The most recent credit limit indicates the per month spending limit granted to a borrower and indicates the level of trust that
* other lenders have had in the person. A person granted a higher credit limit is supposed to be more credible and likely to pay 
* the lender back. 
*/

(do-backward-chaining recentCreditLimit)                              


/*
* Charge-offs occur when lenders have given up on trying to collect the loan and thus file for a charge off.
* When charge-offs are filed by the lender it is a huge stain on the the borrowers credit score and indicates that the borrower
* is not reliable.
*/
(do-backward-chaining chargeOffs)


/*
* If a person has filed for bankruptcies in the past it means that they have had trouble paying off their debts previously. Thus,
* this line backward chains if the applicant has had any bankruptcies in the past
*
* Filing for bankruptcy is a legal action one can take to oficially declare that they cannot pay back their debts. 
*/
(do-backward-chaining bankruptcies)


/*
* Backward chains the debt to income ratio of a potential applicant. The debt to income ratio should be low, a good ratio is 
* around 36% and this ratio cannot exceed 45% for a mortgage. It is taken by dividing monthly debt payments by monthly income.
*/
(do-backward-chaining dti)                                            


/*
* This backwards chains the average credit history length of a persons accounts. The longer accounts have been active, the more
* credible a person is. Longer average length of accounts means that they have been able to maintain good credit over long
* stretches of time.
*/
(do-backward-chaining avgCreditHistoryLength)                        


/*
* This backward chains what type (if any) of new credit that the borrower has recently acquired. If a person has just acquired a 
* substantial loan, then they are less likely to be able to take on more debt on top of that, so it is important to monitor any
* new credit being acquired by the consumer
*/
(do-backward-chaining newCredit) 


/*
* Backward chains how many different types of credit a person has, or their 'credit mix'. People with larger credit mixes are 
* proven to be more trustworthy according to FICO, so this is a variable that should be monitored closely.
*/
(do-backward-chaining creditMix)


/*
* This backward chains the variable used to monitor how many inquiries there have been into the persons credit score by other
* potential lenders. If there are a high number of inquiries in a short period of time, it means that the potential borrower 
* is lookiing to take on more debts and can be considered a risk, so their credit score would be relatively higher.
*/
(do-backward-chaining creditInquiries)


/*
* Backward chains to determine how many accounts a person has had sent to collections. Collections occurs when a person is unable
* to pay back their debts monetarily, so a collection agency is called to come and take physical property to pay back the debts.
* Even if there is just 1 instance of a collection, it indicates a lot of risk
*/
(do-backward-chaining collections)


/*
* Backward chains the criminal history of a person in terms of penalties, misdemeanors, and felonies.
* Those with extensive criminal history are generally considered to be more of a risk
*/
(do-backward-chaining criminal)


/*
* Backward chains the yearly income of a person
*/
(do-backward-chaining income)


/*
* Backward chains what level of degree or education a person has achieved in order to determine how easily they will be able to 
* get a job and pay back any debts
*/
(do-backward-chaining education)


/*
* Backward chains the borrower's spouse's credit score because if married, it is most likely that their ability to pay back debts
* will be largely similar to whom they marry. 
*/
(do-backward-chaining maritalStatus)


/*
* Backward chains to determine if the borrower is involved in any legal cases that could complicate their ability to pay back 
* loans. These show up on one's credit report as 'legal judgements'
*/
(do-backward-chaining legalJudgements)


/*
* Backward chains to determine if the borrower has had any type of tax lien in the past or has never been issued a tax lien. A tax lien
* occurs when someone is unable to pay their taxes, and if someone is unable to pay their taxes, it is probable that they won't be able
* to pay back their debts.
*/
(do-backward-chaining taxLiens)


/*
* This Backward chains a borrowers credit score as issued by FICO. Through ingratiating FICO's own credit scoring system, this score will 
* be able to be similarly precise.
*/
(do-backward-chaining creditScoreFICO)


/*
* This backward chains a borrowers FICO insurance score. This score is supposed to determine the risk of someone getting into an accident, 
* which would also affect their risk for a loan, so it should also be incorporated here.
*/
(do-backward-chaining healthInsuranceScore)


/*
* Backward chains a person's FICO auto insurance score which determins the risk of any car related problems or fees that would be incurred.
* This would be relevant because if someone is at a high risk for getting into a car accident, then they are also at a high risk for taking
* on other debts/financial problems.
*/
(do-backward-chaining autoInsuranceScore)





(defrule startup "Starts up the credit score program through listing the instructions for the user."

   (declare (salience 100))                                                    ; sets the salience as a high number so that it will fire first

=>

   (printout t crlf "This program will ask you a series of questions to generate a credit score between 1 and 100." crlf
    "Then, the program will generate possible loans the borrower could acquire given their credit score." crlf
    "The program's questions can be answered through analyzing the borrower's credit report as well as interviewing the canidate for other details."
    crlf crlf)
)







/*
* Sections below are used to define the functions that read, interpret, backward chain, and score the categories listed above.
* The general structure used for each category is the same, so as an example for functionality look to the first varriable below for credit
* utilization which is thoroughly commented. Beyond Utilization, only unique structures within each category will be commented.
* The function/rule names will vary based on the name of the category, but all have the same functionality to read in, verify, and assert a given
* category that determines a credit score.
*/




(defrule creditUtilizationBackward "Rule to Backward-Chain the characteristic creditUtilization. This can be found on the credit report and is 
the ratio of how much a person spends each month to how much their credit limit is."
    
    (need-creditUtilization ?)

    =>

    /*
    * calls the getAnsUtilization function to get the user's valid response to the question and bind it to a variable.
    */
    (bind ?ans (getAnsUtilization "Enter the percent credit utilization of the borrower (from 0 to 100 inclusive) without the percentage sign(%) "))
    
    /*
    * Once an input has been entered, creditUtilization will be asserted to found, so that the rules to categorize the user input can be triggered.
    */
    (assert (creditUtilization found))


    /*
    * the percentage entered is stored in a variable that is not backward chained, so that functions can be executed on the variable during pattern matching 
    */
    (assert (utilizationPercentage ?ans))                                        
    
)


/*
* function to continuously ask for credit utilization while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt credit utilization
*/
(deffunction getAnsUtilization (?asking)

   (bind ?done FALSE)                                                          ; boolean variable to check whether or not a valid input has been submitted.
   

   (while (not ?done)                                                          ; while a valid input has not been submitted 
    
      (bind ?ans (ask ?asking))                                                ; uses ask from toolbox to ask and save the answer of the user
      (printout t " "crlf)

      (bind ?interpreted (interpretUtilization ?ans))                          ; calls interpret function to interpret and save the validity of an answer

      (if (= ?interpreted "valid") then                                        ; checks to see if the response given by the user is valid 
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf).        ; prompts the user that their input is invalid

         (printout t "Don't forget to drop the percentage sign!" crlf)
         (printout t " " crlf)
      )
   )

)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for credit utilization.
* Will return either valid or "not possible" based on the validity of the solution
*/
(deffunction interpretUtilization (?response)
   
   
   (bind ?ans "not possible")                                                   
   
   
   (if (and (integerp ?response) (and (>= ?response 0) (<= ?response 100)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestUtilization  "If utilization entered is between 0 and 10 then it's the best possible and will get a score of 100 for this category" 

   (creditUtilization found)

   /*
   * if the util percent found is between 0 and 10, then it is considered to be top tier.
   */ 
   (utilizationPercentage ?X&:(< ?X 10)&:(<= 0 ?X))                             


    =>

    /*
    * This asserts 100 to a fact specifically designed to hold the score given for this category
    */
    (assert (utilizationScore 100))
  
)

(defrule goodUtilization  "If the utilization entered is between 20 and 10 then a score of 90 will be assigned for this category" 

   (creditUtilization found)

   /*
   * if the util percent found is between 10 and 20, then it is considered to be second tier.
   */ 
   (utilizationPercentage ?X&:(< ?X 20)&:(<= 10 ?X))


    =>

    (assert (utilizationScore 90))

)

(defrule okUtilization  "If the utilization entered is between 30 and 20 then score of 80 will be assignedfor this category" 

   (creditUtilization found)

   /*
   * if the util percent found is between 30 and 20, then it is considered to be third tier.
   */ 
   (utilizationPercentage ?X&:(< ?X 30)&:(<= 20 ?X))

    =>

    (assert (utilizationScore 80))

)

(defrule mediocreUtilization  "If the utilization entered is between 30 and 40 then a score of 70 will be assigned for this category" 

   (creditUtilization found)

   /*
   * if the util percent found is between 30 and 40, then it is considered to be fourth tier.
   */ 
   (utilizationPercentage ?X&:(< ?X 40)&:(<= 30 ?X))


    =>

    (assert (utilizationScore 70))

)

(defrule strugglingScore  "If the utilization entered is between 70 and 40 then a score of 50 will be assigned for this category"

   (creditUtilization found)

   /*
   * if the util percent found is between 70 and 40, then it is considered to be fifth tier.
   */ 
   (utilizationPercentage ?X&:(< ?X 70)&:(<= 40 ?X))

    =>

    (assert (utilizationScore 50))

)

(defrule abysmalUtilization  "If the utilization entered is between 70 and 100 then a score of 30 will be assigned for this category"

   (creditUtilization found)

   /*
   * if the util percent found is between 70 and 100, then it is considered to be sixth tier.
   */ 
   (utilizationPercentage ?X&:(<= 70 ?X)&:(<= ?X 100))


    =>

    (assert (utilizationScore 30))

)





/*
* Section to read, interpret, backward chain, and score the borrower's most recent credit limit. Look to credit utilization for 
* generalized comments.
*/



(defrule recentCreditLimitBackward "Rule to Backward-Chain the most recent credit limit of a borrower"
    
    (need-recentCreditLimit ?)
    =>
    (bind ?ans (getAnsLimit "Enter the most recent dollar amount credit limit of the borrower (if none enter 0) "))
    (assert (recentCreditLimit found))
    (assert (limitAmount ?ans))
    
)


/*
* function to continuously ask for credit limit while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt credit limit
*/
(deffunction getAnsLimit (?asking)

   (bind ?done FALSE)                                                 

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking))                                      
      (printout t " "crlf)

      (bind ?interpreted (interpretLimit ?ans))                     

      (if (= ?interpreted "valid") then                               
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else 
         (printout t "That's an invalid input for the question!" crlf)
         (printout t "Don't forget to exclude commas!" crlf)
         (printout t " " crlf)
      )
   )

)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for credit limit.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretLimit (?response)
   
   (bind ?ans "not possible")
   
   (if (and (integerp ?response) (>= ?response 0) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestLimit "If  limit entered is greater than 50,000 then it's the best possible and should receive a score of 100 for this category"  

   (recentCreditLimit found)
   (limitAmount ?X&:(<= 50000 ?X ))

    =>
 
    (assert (limitScore 100))

)

(defrule goodLimit "If the limit entered is between 50,000 and 25,000 then it should receive a score of 90 for this category"  

   (recentCreditLimit found)
   (limitAmount ?X&:(< ?X 50000)&:(<= 25000 ?X))


    =>

    (assert (limitScore 90))
    
)

(defrule okLimit "If the limit entered is between 11,000 and 25,000 then it should receive a score of 80 for this category"  

   (recentCreditLimit found)
   (limitAmount ?X&:(< ?X 25000)&:(<= 11000 ?X))


    =>

    (assert (limitScore 80))
    
)

(defrule mediocreLimit  "If the limit entered is between 11,000 and 6,000 then it should receive a score of 70 for this category"  

   (recentCreditLimit found)
   (limitAmount ?X&:(< ?X 11000)&:(<= 6000 ?X))


    =>

    (assert (limitScore 70))
    
)

(defrule strugglingLimit  "If the limit entered is between 6,000 and 2,500 then it should receive a score of 50 for this category"  

   (recentCreditLimit found)
   (limitAmount ?X&:(< ?X 6000)&:(<= 2500 ?X))


    =>

    (assert (limitScore 50))
    
)

(defrule abysmalLimit  "If the limit entered is less than 2,5000 then it should receive a score of 30 for this category" 

   (recentCreditLimit found)
   (limitAmount ?X&:(< ?X 2500))


    =>

    (assert (limitScore 30))
    
)






/*
* Section to read, interpret, backward chain, and score borrower's chargeoffs. Look to credit utilization for generalized comments.
*/


(defrule chargeOffsBackward "Rule to Backward-Chain the characteristic chargeOffs"
    
    (need-chargeOffs ?)
    =>
    (bind ?ans (getAnsChargeOffs "Enter the number of accounts which have been designated as a chargeoff "))
    (assert (chargeOffs found))
    (assert (numChargeOffs ?ans))
    
)


/*
* function to continuously ask for charge-offs while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt charge-offs
*/
(deffunction getAnsChargeOffs (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                
    
      (bind ?ans (ask ?asking))                                       

      (bind ?interpreted (interpretChargeOffs ?ans))                  

      (if (= ?interpreted "valid") then                     
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf); prompts the user that their input is invalid

         (printout t "Max is 10 " crlf)
         (printout t " " crlf)
      )
   )

   (return)
)

/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for credit limit.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretChargeOffs (?response)
   
   (bind ?ans "not possible")
   
   (if (and (integerp ?response) (and (>= ?response 0) (<= ?response 10)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestChargeOff  "If there are no charge-offs then it is the best possible and should receive a score of 100 for this category"  

   (chargeOffs found)
   (numChargeOffs 0)


    =>


    (assert (chargeOffScore 100))
  
)


(defrule mediocreChargeOff "If there is 1 charge-off then it should receive a score of 30 for this category"  

   (chargeOffs found)
   (numChargeOffs 1)


    =>

    (assert (chargeOffScore 30))
  
)

(defrule abysmalChargeOff  "If there are 2 charge-offs or more then it should receive a score of 0 for this category" 

   (chargeOffs found)
   (numChargeOffs ?X&:(>= ?X 2))


    =>

    (assert (chargeOffScore 0))
  
)





/*
* Section to read, interpret, backward chain, and score borrower's bankruptcies. Look to credit utilization for generalized comments.
*/


(defrule bankruptcyBackward "Rule to Backward-Chain the characteristic for number of time bankruptcy was filed"
    
    (need-bankruptcies ?)
    =>
    (bind ?ans (getAnsBankruptcies "Enter the number of times the borrower has filed for bankruptcy "))
    (assert (bankruptcies  found))
    (assert (numBankruptcies ?ans))
    
)


/*
* function to continuously ask for bankruptcies while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt bankruptcies
*/
(deffunction getAnsBankruptcies (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking))                                       
      (printout t " "crlf)

      (bind ?interpreted (interpretBankruptcies ?ans))                

      (if (= ?interpreted "valid") then                                
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf)

         (printout t "Try again! " crlf)
         (printout t " " crlf)
      )
   )

)

/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for Bankruptcies.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretBankruptcies (?response)
   
   (bind ?ans "not possible")
   (if (and (integerp ?response) (and (>= ?response 0) (<= ?response 10)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestBankruptcy  "If there are no bankruptcies then it is the best possible and should receive a score of 100 for this category" 

   (bankruptcies found)
   (numBankruptcies 0)


    =>

    (assert (bankruptcyScore 100))
  
)


(defrule mediocreBankruptcy  "If there is 1 bankruptcy then it should receive a score of 30 for this category" 

   (bankruptcies found)
   (numBankruptcies 1)


    =>

    (assert (bankruptcyScore 30))
  
)

(defrule abysmalBankruptcy  "If there are 2 bankruptcies or more then it should receive a score of 0 for this category"  

   (bankruptcies found)
   (numBankruptcies ?X&:(>= ?X 2))


    =>

    (assert (bankruptcyScore 0))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's Collections. Look to credit utilization for generalized comments.
*/


(defrule collectionsBackward "Rule to Backward-Chain the accounts in collections"
    
    (need-collections ?)
    =>

    /*
    * Calls the getAnsBankruptcies because validity conditions for bankruptcy and collections are same.
    */
    (bind ?ans (getAnsBankruptcies "Enter how many accounts the borrower has had sent to collections"))

    (assert (collections  found))
    (assert (numCollections ?ans))
    
)

(defrule bestCollections  "If no collections have been initiated then a score of 100 will be received for this category" 

   (collections found)
   (numCollections 0)


    =>

    (assert (collectionsScore 100))
  
)


(defrule mediocreCollections  "If one collection has been initiated then a score of 30 will be received for this category" 
   
   (collections found)
   (numCollections 1)


    =>

    (assert (collectionsScore 30))
  
)

(defrule abysmalCollections  "If two collections have been initiated then a score of 0 will be received for this category"  

   (bankruptcies found)
   (numCollections ?X&:(>= ?X 2))


    =>

    (assert (collectionsScore 0))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's debt to income ratio. Look to credit utilization for generalized comments.
*/


(defrule dtiBackward "Rule to Backward-Chain the characteristic of debt to income ratio"
    
    (need-dti ?)
    =>
    (bind ?ans (getAnsDTI "Enter the borrower's 'debt to income ratio' percentage (without the percent sign) "))
    (assert (dti  found))
    (assert (dtiPercentage ?ans))
    
)


/*
* function to continuously ask for debt to income ratio while a valid input has not been entered yet. Once entered, the program will 
* return the answer given by the user.
* Argument passed through is the question to be asked to prompt debt to income ratio.
*/
(deffunction getAnsDTI (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking))                                      
      (printout t " "crlf)

      (bind ?interpreted (interpretDTI ?ans))                        

      (if (= ?interpreted "valid") then                                
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf)

         (printout t "Don't forget to remove the percentage sign! " crlf)
         (printout t " " crlf)
      )
   )

   
)

/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for DTI (debt-to-income) ratio.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretDTI (?response)
   
   (bind ?ans "not possible")

   (if (and (integerp ?response) (and (>= ?response 0) (<= ?response 100)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestDTI "If the DTI ratio is between 0 and 10 then a score of 100 will be assigned for this category" 

   (dti found)
   (dtiPercentage ?X&:(<= 0 ?X)&:(< ?X 10))


    =>

    (assert (dtiScore 100))
  
)


(defrule goodDTI "If the DTI ratio is between 20 and 10 then a score of 90 will be assigned for this category" 

   (dti found)
   (dtiPercentage ?X&:(<= 10 ?X)&:(< ?X 20))


    =>

    (assert (dtiScore 90))
  
)


(defrule okDTI  "If the DTI ratio is between 20 and 35 then a score of 80 will be assigned for this category" 

   (bankruptcies found)
   (dtiPercentage ?X&:(<= 20 ?X)&:(< ?X 35))


    =>

    (assert (dtiScore 80))
  
)


(defrule mediocreDTI  "If the DTI ratio is between 35 and 50 then a score of 70 will be assigned for this category"

   (bankruptcies found)
   (dtiPercentage ?X&:(<= 35 ?X)&:(< ?X 50))


    =>

    (assert (dtiScore 70))
  
)

(defrule strugglingDTI  "If the DTI ratio is between 50 and 70 then a score of 50 will be assigned for this category" 

   (bankruptcies found)
   (dtiPercentage ?X&:(<= 50 ?X)&:(< ?X 70))


    =>

    (assert (dtiScore 50))
  
)

(defrule abysmalDTI  "If the DTI ratio is greater than or equal to 70 then a score of 25 will be assigned for this category"

   (bankruptcies found)
   (dtiPercentage ?X&:(<= 70 ?X))


    =>

    (assert (dtiScore 25))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's average credit history length. 
* Look to credit utilization for generalized comments.
*/



(defrule avgCreditHistoryLengthBackward "Rule to Backward-Chain the characteristic of avg credit history length"
    
    (need-avgCreditHistoryLength ?)
    =>
    (bind ?ans (getAnsHistory "Enter the average age of the borrower's past loans, rounding to the nearest whole year (if no previous loans enter 0) "))
    (assert (avgCreditHistoryLength  found))
    (assert (historyLength ?ans))
    
)


/*
* function to continuously ask for avg credit history length while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt history length.
*/

(deffunction getAnsHistory (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                  
    
      (bind ?ans (ask ?asking))                                       
      (printout t " "crlf)

      (bind ?interpreted (interpretHistory ?ans))                     

      (if (= ?interpreted "valid") then                              
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf); prompts the user that their input is invalid

         (printout t "Try Again! " crlf)
         (printout t " " crlf)
      )
   )

)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for avg credit history length.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretHistory (?response)
   
   (bind ?ans "not possible")

   (if (and (integerp ?response) (and (>= ?response 0) (<= ?response 75)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestHistory "If the length is greater than or equal to 15, then ascore of 100 should be assigned for this category" 

   (avgCreditHistoryLength found)
   (historyLength ?X&:(<= 15 ?X))


    =>

    (assert (historyScore 100))
  
)


(defrule goodHistory "If the length is between 10 and 15, then ascore of 90 should be assigned for this category"  

   (avgCreditHistoryLength found)
   (historyLength ?X&:(<= 10 ?X)&:(< ?X 15))


    =>

    (assert (historyScore 90))
  
)


(defrule okHistory "If the length is between 7 and 10, then ascore of 80 should be assigned for this category"   

   (avgCreditHistoryLength found)
   (historyLength ?X&:(<= 7 ?X)&:(< ?X 10))


    =>

    (assert (historyScore 80))
  
)


(defrule mediocreHistory "If the length is between 5 and 7, then ascore of 70 should be assigned for this category" 

   (avgCreditHistoryLength found)
   (historyLength ?X&:(<= 5 ?X)&:(< ?X 7))


    =>

    (assert (historyScore 70))
  
)

(defrule strugglingHistory "If the length is between 3 and 5, then ascore of 50 should be assigned for this category"   

   (avgCreditHistoryLength found)
   (historyLength ?X&:(<= 3 ?X)&:(< ?X 5))


    =>

    (assert (historyScore 50))
  
)

(defrule abysmalHistory "If the length is between 0 and 3, then ascore of 30 should be assigned for this category"   

   (avgCreditHistoryLength found)
   (historyLength ?X&:(<= 0 ?X)&:(< ?X 3))


    =>

    (assert (historyScore 30))
  
)



/*
* Section to read, interpret, backward chain, and score borrower's new credit. Look to credit utilization for generalized comments.
*/


(defrule newCreditBackward "Rule to Backward-Chain the characteristic of what new credit is being acquired"
    
    (need-newCredit ?)
    =>

    /*
    * This function provides a list of possibilities from which the user will select one
    */
    (printout t " " crlf)
    (printout t "Enter one of the letters below to indicate information about new credit being acquired: " crlf)
    (printout t "A. Credit Card Loan " crlf)
    (printout t "B. Unsecured Loan" crlf)
    (printout t "C. Multiple Credit Card Loans" crlf)
    (printout t "D. Multiple Unsecured Loans" crlf)
    (printout t "E. Auto Loans" crlf)
    (printout t "F. Home Equity Loan" crlf)
    (printout t "G. Mortgage" crlf)
    (printout t "H. NONE" crlf)
    (printout t " " crlf)

    (bind ?ans (getAnsNewCredit"Type the letter that corresponds to any new credit being acquired by the borrower. Enter 'H' if there is no new credit "))
    (assert (newCredit  found))
    (assert (creditType ?ans))
    
)


/*
* function to continuously ask for what new credit is being added while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt new credit
*/

(deffunction getAnsNewCredit (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking)) 
      (bind ?ans (lowcase ?ans))
      (printout t " " crlf)

      (bind ?interpreted (interpretNew ?ans)).                        

      (if (= ?interpreted "valid") then                              
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf); prompts the user that their input is invalid

         (printout t "Make sure you entered the right letter! " crlf)
         (printout t " " crlf)
      )
   )


)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for new credit.
* Will return either valid or "not possible" based on the validity of the solution.
*/

(deffunction interpretNew (?response)
  
  (bind ?ans "not possible")

  (if (and (not (integerp ?response)) (or (= ?response "a") (= ?response "b") (= ?response "c") (= ?response "d") (= ?response "e") 
  (= ?response "f") (= ?response "g") (= ?response "h")) ) then
      
      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestNew  "If option 'h' was selected, then there is no new credit and  a score of 100 will be given for this category"

   (newCredit found)
   (creditType h)


    =>
  
    (assert (newScore 100))
  
)

(defrule goodNew  "If option 'a' was selected, then there is a new credit card loan and  a score of 80 will be given for this category" 

   (newCredit found)
   (creditType a)


    =>

    (assert (newScore 80))
  
)

(defrule mediocreNew  "If option 'b' was selected, then there is a new unsecured loan and a score of 65 will be given for this category"  

   (newCredit found)
   (creditType b)


    =>

    (assert (newScore 65))
  
)

(defrule belowAverageNew  "If option 'c' was selected, then there are multiple new credit card loans and a score of 50 will be given for this category" 

   (newCredit found)
   (creditType c)


    =>

    (assert (newScore 50))
  
)

(defrule strugglingNew  "If option 'd' was selected, then then there are multiple new unsecured loans and a score of 40 will be given for this category"

   (newCredit found)
   (creditType d)


    =>

    (assert (newScore 40))
  
)

(defrule autoNew  "If option 'e' was selected then there is a new auto loan and a score of 10 will be given for this category" 

   (newCredit found)
   (creditType e)


    =>

    (assert (newScore 10))
  
)

(defrule homeEquityNew  "If option 'f' was selected, then there is a new home equity loan and a score of 5 will be given for this category" 

   (newCredit found)
   (creditType f)


    =>

    (assert (newScore 5))
  
)

(defrule mortgageNew  "If option 'g' was selected, then there is a new mortgage and a score of 1 will be given for this category"  

   (newCredit found)
   (creditType g)


    =>

    (assert (newScore 1))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's criminal background. 
* Look to credit utilization for generalized comments.
*/



(defrule criminalBackward "Rule to Backward-Chain the characteristic of one's criminal history"
    
    (need-criminal ?)
    =>

    /*
    * This function provides a list of possibilities from which the user will select one
    */
    (printout t " " crlf)
    (printout t "Enter one of the letters below to indicate borrower's criminal record: " crlf)
    (printout t "A. Criminal Penalties " crlf)
    (printout t "B. Multiple Penalties" crlf)
    (printout t "C. Misdemeanor" crlf)
    (printout t "D. Multiple Misdemeanors" crlf)
    (printout t "E. Felony" crlf)
    (printout t "F. Multiple Felonies" crlf)
    (printout t "G. NONE" crlf)
    (printout t " " crlf)

    (bind ?ans (getAnsCriminal "Type the letter that corresponds to any criminal charges faced by the borrower. Enter 'G' if there are none "))
    (assert (criminal  found))
    (assert (criminalType ?ans))
    
)


/*
* function to continuously ask for criminal history while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt criminal history.
*/
(deffunction getAnsCriminal (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking)) 
      (bind ?ans (lowcase ?ans))
      (printout t " " crlf)

      (bind ?interpreted (interpretCriminal ?ans))                    

      (if (= ?interpreted "valid") then                               
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf)

         (printout t "Make sure you entered the right letter! " crlf)
         (printout t " " crlf)
      )
   )

)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for the question on criminal history.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretCriminal (?response)
  
  (bind ?ans "not possible")

  (if (and (not (integerp ?response)) (or (= ?response "a") (= ?response "b") (= ?response "c") 
  (= ?response "d") (= ?response "e") (= ?response "f") (= ?response "g")) ) then
      
      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule penaltyCriminal  "If criminal of type a, then they have committed a penalty and will be given a score of 80 for the category "  

   (criminal found)
   (criminalType a)

    =>

    (assert (criminalScore 80))
  
)

(defrule manyPenaltyCriminal "If criminal of type a, then they have committed multiple penalties and will be given a score of 60 for the category "  

   (criminal found)
   (criminalType b)

    =>

    (assert (criminalScore 60))
  
)

(defrule misdemeanorsCriminal  "If criminal of type c, then they have committed a misdemeanor and will be given a score of 40 for the category "  

   (criminal found)
   (criminalType c)

    =>

    (assert (criminalScore 40))
  
)

(defrule manyMisdemeanorsCriminal  "If criminal of type d, then they committed multiple misdemeanors and will be given a score of 80 for the category" 

   (criminal found)
   (criminalType d)

    =>

    (assert (criminalScore 20))
  
)

(defrule felonyCriminal  "If they answered criminal of type e, then the committed a felony and will be given a score of 10 for the category"  

   (criminal found)
   (criminalType e)

    =>

    (assert (criminalScore 10))
  
)

(defrule manyFelonyCriminal "If they answered criminal of type f, then they have committed multiple felonies and will be given a score of 0"  

   (criminal found)
   (criminalType f)

    =>

    (assert (criminalScore 0))
  
)


(defrule innocentCriminal  "If they answered criminal of type g, then they have no criminal history and are assigned a score of 100 for the category"  

   (criminal found)
   (criminalType g)

    =>
    
    (assert (criminalScore 100))
  
)



/*
* Section to read, interpret, backward chain, and score borrower's credit mix. Look to credit utilization for generalized comments.
*/


(defrule creditMixBackward "Rule to Backward-Chain the characteristic for credit mix"
    
    (need-creditMix ?)
    =>
    (bind ?ans (getAnsMix "Enter how many different types of loans the borrower has had (if none enter 0) "))
    (assert (creditMix  found))
    (assert (numMix ?ans))
    
)


/*
* function to continuously ask for credit mix while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt credit mix.
*/
(deffunction getAnsMix (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking))                                       
      (printout t " "crlf)

      (bind ?interpreted (interpretMix ?ans))               

      (if (= ?interpreted "valid") then                               
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf)

         (printout t "Try again! " crlf)
         (printout t " " crlf)
      )
   )

)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for credit mix.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretMix (?response)
   
   
   (bind ?ans "not possible")
   (if (and (integerp ?response) (and (>= ?response 0) (<= ?response 15)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestMix  "If the borrower has over 4 types of credit, then a score of 100 will be assigned for this category." 

   (creditMix found)
   (numMix ?X&:(<= 4 ?X))


    =>
    
    (assert (creditMixScore 100))
  
)


(defrule goodMix  "If the borrower has 3 types of credit, then a score of 85 will be assigned for this category."  

   (creditMix found)
   (numMix 3)


    =>

    (assert (creditMixScore 85))
  
)


(defrule okMix  "If the borrower has 2 types of credit, then a score of 70 will be assigned for this category."  

   (creditMix found)
   (numMix 2)


    =>

    (assert (creditMixScore 70))
  
)

(defrule strugglingMix  "If the borrower has 1 type of credit, then a score of 55 will be assigned for this category." 

   (creditMix found)
   (numMix 1)


    =>

    (assert (creditMixScore 55))
  
)

(defrule abysmalMix  "If the borrower has not had any credit yet, then a score of 10 will be assigned for this category." 

   (creditMix found)
   (numMix 0)


    =>

    (assert (creditMixScore 10))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's credit Inquiries. 
* Look to credit utilization for generalized comments.
*/


(defrule creditInquiriesBackward "Rule to Backward-Chain the characteristic of credit inquiries"
    
    (need-creditInquiries ?)
    =>

    /*
    * Used the same getAnsMix function that is used in the credit mix rule above because both credit mix and credit inquiries
    * have the same validation functions
    */
    (bind ?ans (getAnsMix "Enter how many credit report inquiries have occured in regards to the borrower's account "))

    (assert (creditInquiries  found))
    (assert (numInquiries ?ans))
)



(defrule bestInquiries  "If there have been 0 inquiries then assign a score of 100 for this category" 

   (creditInquiries found)
   (numInquiries 0)


    =>
  
    (assert (creditInquiriesScore 100))
  
)


(defrule goodInquiries  "If there have been between 0 and 3 inquiries then assign a score of 85 for this category"

   (creditInquiries found)
   (numInquiries ?X&:(< 0 ?X)&:(<= ?X 3))


    =>

    (assert (creditInquiriesScore 85))
  
)

(defrule okInquiries  "If there have been between 5 and 3 inquiries then assign a score of 60 for this category"

   (creditInquiries found)
   (numInquiries ?X&:(< 3 ?X)&:(<= ?X 5))


    =>

    (assert (creditInquiriesScore 60))
  
)

(defrule strugglingInquiries  "If there have been more than 5 inquiries then assign a score of 85 for this category"

   (creditInquiries found)
   (numInquiries ?X&:(< 5 ?X))


    =>

    (assert (creditInquiriesScore 45))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's income. Look to credit utilization for generalized comments.
*/

(defrule incomeBackward "Rule to Backward-Chain the characteristic of income"
    
    (need-income ?)
    =>
    (bind ?ans (getAnsIncome "Enter the borrower's pre-tax income "))
    (assert (income  found))
    (assert (incomeAmount ?ans))
    
)


/*
* function to continuously ask for income while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt income
*/
(deffunction getAnsIncome (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking))                                       
      (printout t " "crlf)

      (bind ?interpreted (interpretIncome ?ans))                      

      (if (= ?interpreted "valid") then                                
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf)

         (printout t "Try Again ! " crlf)
         (printout t " " crlf)
      )
   )

)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for income.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretIncome (?response)
   
   (bind ?ans "not possible")  


   (if (and (integerp ?response) (>= ?response 0)) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestIncome  "If income is greater than 500,000, then assign a score of 100 for this category"

   (income found)
   (incomeAmount ?X&:(<= 500000 ?X))


    =>

    (assert (incomeScore 100))
  
)

(defrule goodIncome  "If income is between 150,000 and 50,000, then assign a score of 90 for this category"

   (income found)
   (incomeAmount ?X&:(<= 150000 ?X)&:(< ?X 500000))


    =>

    (assert (incomeScore 90))
  
)


(defrule okIncome  "If income is between 150,000 and 80,000, then assign a score of 85 for this category" 

   (income found)
   (incomeAmount ?X&:(<= 80000 ?X)&:(< ?X 150000))


    =>

    (assert (incomeScore 85))
  
)

(defrule mediocreIncome  "If income is between 40,000 and 80,000, then assign a score of 75 for this category"

   (income found)
   (incomeAmount ?X&:(<= 40000 ?X)&:(< ?X 80000))


    =>

    (assert (incomeScore 75))
  
)

(defrule strugglingIncome  "If income is between 15,000 and 40,000, then assign a score of 45 for this category" 

   (income found)
   (incomeAmount ?X&:(<= 15000 ?X)&:(< ?X 40000))


    =>

    (assert (incomeScore 45))
  
)

(defrule worstIncome  "If income is less than 15,000, then assign a score of 10 for this category" 

   (income found)
   (incomeAmount ?X&:(< ?X 15000))


    =>

    (assert (incomeScore 10))
  
)



/*
* Section to read, interpret, backward chain, and score borrower's education. Look to credit utilization for generalized comments.
*/


(defrule educationBackward "Rule to Backward-Chain the characteristic of one's educational background"
    
    (need-education ?)
    =>

    /*
    * This rule provides a list for the user to choose from
    */

    (printout t " " crlf)
    (printout t "Enter one of the letters below to indicate borrower's level of education: " crlf)
    (printout t "A. 4-year college degree " crlf)
    (printout t "B. 2-year highschool degree" crlf)
    (printout t "C. Highschool graduate" crlf)
    (printout t "D. Highschool dropout" crlf)
    (printout t " " crlf)

    (bind ?ans (getAnsEducation "Type the letter that corresponds to the borrower's level of education "))
    (assert (education  found))
    (assert (educationType ?ans))
    
)


/*
* function to continuously ask for education while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt education
*/

(deffunction getAnsEducation (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking)) 
      (bind ?ans (lowcase ?ans))
      (printout t " " crlf)

      (bind ?interpreted (interpretEducation ?ans))                   

      (if (= ?interpreted "valid") then                                
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf)

         (printout t "Make sure you entered the right letter! " crlf)
         (printout t " " crlf)
      )
   )

)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for education.
* Will return either valid or "not possible" based on the validity of the solution.
*/

(deffunction interpretEducation (?response)
  
  (bind ?ans "not possible")
  
  (if (and (not (integerp ?response)) (or (= ?response "a") (= ?response "b") (= ?response "c") (= ?response "d")) ) then
      
      (bind ?ans valid)
   )

   (return ?ans)

)


(defrule highEducation  "If education level 'a' was chosen, then the borrower has a a 4-year college degree and will be given
 a score of 100 for this category"  

   (education found)
   (educationType a)

    =>

    (assert (educationScore 100))
  
)

(defrule middleEducation  "If education level 'b' was chose, then the borrower has a a 2-year college degree and will be given
 a score of 75 for this category"  

   (education found)
   (educationType b)

    =>

    (assert (educationScore 75))
  
)


(defrule lowEducation  "If education level 'c' was chose, then the borrower has a a high school degree and will be given
 a score of 50 for this category"  

   (education found)
   (educationType c)

    =>

    (assert (educationScore 50))
  
)

(defrule lowestEducation  "If education level 'd' was chosen, then the borrower is a highschool dropout and will be given
 a score of 25 for this category"

   (education found)
   (educationType d)

    =>

    (assert (educationScore 25))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's spouse's FICO score. 
* Look to credit utilization for generalized comments.
*/

(defrule maritalStateBackward "Rule to Backward-Chain the FICO score of one's spouse "
    
    (need-maritalStatus ?)
    =>

    (bind ?ans (getAnsSpouse "Enter the borrower's spouse's credit score. If unmarried, enter 851"))
    (assert (maritalStatus  found))
    (assert (married ?ans))
    
)


/*
* function to continuously ask for spouse's credit score while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt for spouse's credit score
*/
(deffunction getAnsSpouse (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking))                                       
      (printout t " "crlf)

      (bind ?interpreted (interpretSpouse ?ans))                      

      (if (= ?interpreted "valid") then                                
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf)

         (printout t "Try Again ! " crlf)
         (printout t " " crlf)
      )
   )

   (return)
)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for FICO credit scores.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretSpouse (?response)
   
   (bind ?ans "not possible")
   (if (and (integerp ?response) (and (>= ?response 300) (<= ?response 851)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestSpouse  "If the spouse's FICO credit score is 750, then assign a score of 100 for this category" 

   (maritalStatus found)
   (married ?X&:(<= 750 ?X))


    =>

    (assert (maritalScore 100))
  
)

(defrule goodSpouse "If the spouse's FICO credit score is between 700 and 750, then assign a score of 90 for this category"  

   (maritalStatus found)
   (married ?X&:(<= 700 ?X)&:(< ?X 750))


    =>

    (assert (maritalScore 90))
  
)

(defrule noSpouse  "If the person is not married then assign a score of 95 for this category"   

   (maritalStatus found)
   (married 851)


    =>

    (assert (maritalScore 95))
  
)

(defrule okSpouse  "If the spouse's FICO credit score is between 650 and 700, then assign a score of 70 for this category"   

   (maritalStatus found)
   (married ?X&:(<= 650 ?X)&:(< ?X 700))


    =>

    (assert (maritalScore 70))
  
)

(defrule badSpouse  "If the spouse's FICO credit score is between 550 and 650, then assign a score of 50 for this category"   

   (maritalStatus found)
   (married ?X&:(<= 550 ?X)&:(< ?X 650))


    =>

    (assert (maritalScore 50))
  
)

(defrule terribleSpouse  "If the spouse's FICO credit score is between 300 and 550, then assign a score of 25 for this category"   

   (maritalStatus found)
   (married ?X&:(<= 300 ?X)&:(< ?X 550))


    =>

    (assert (maritalScore 25))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's legal background. Look to credit utilization for generalized comments.
*/

(defrule legalBackward "Rule to Backward-Chain the characteristic of one's legal judgements"
    
    (need-legalJudgements ?)
    =>

    (printout t " " crlf)
    (printout t "Enter one of the letters below to indicate borrower's legal judgements: " crlf)
    (printout t "A. Vacated/Refiled Judgement" crlf)
    (printout t "B. Satisfied Judgement" crlf)
    (printout t "C. Unsatisfied Judgement" crlf)
    (printout t "D. NONE" crlf)
    (printout t " " crlf)

    (bind ?ans (getAnsLegal "Enter the letter that corresponds to the borrower's past/present legal judgements. if none enter D "))
    (assert (legalJudgements  found))
    (assert (judgement ?ans))
    
)


/*
* function to continuously ask for legal status while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt legal status
*/

(deffunction getAnsLegal (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking)) 
      (bind ?ans (lowcase ?ans))
      (printout t " " crlf)

      (bind ?interpreted (interpretLegal ?ans))                       


      (if (= ?interpreted "valid") then                                
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf); prompts the user that their input is invalid

         (printout t "Make sure you entered the right letter! " crlf)
         (printout t " " crlf)
      )
   )

   (return)
)



/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for a legal status.
* Will return either valid or "not possible" based on the validity of the solution.
*/

(deffunction interpretLegal (?response)
  
  (bind ?ans "not possible")
  (if (and (not (integerp ?response)) (or (= ?response "a") (= ?response "b") (= ?response "c") (= ?response "d")) ) then
      
      (bind ?ans valid)
  )

   (return ?ans)

)


(defrule noJudgements  "If option d is chosen, then the user has not incurred any judgements and will be assigned a score of 100 for the category"  

   (legalJudgements found)
   (judgement d)

    =>

    (assert (legalJudgementScore 100))
  
)

(defrule vacatedJudgements  "If option a is chosen, then the user has incurred a vacated judgement and will be assigned a score of 85 for the category"   

   (legalJudgements found)
   (judgement a)

    =>

    (assert (legalJudgementScore 85))
  
)


(defrule satisfiedJudgements  "If option b is chosen, the user has incurred a satisfied judgement and will be assigned a score of 60 for the category"    

   (legalJudgements found)
   (judgement b)

    =>

    (assert (legalJudgementScore 60))
  
)

(defrule unsatisfiedJudgements  "If option c is chosen, the user has incurred an unsatisfied judgement and will be assigned a score of 25 for the category"  

   (legalJudgements found)
   (judgement c)

    =>

    (assert (legalJudgementScore 25))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's tax liens. Look to credit utilization for generalized comments.
*/


(defrule taxLiensBackward "Rule to Backward-Chain the characteristic of tax liens "
    
    (need-taxLiens ?)
    =>

    (bind ?ans (getAnsTax "If borrower has any tax liens enter 'yes', otherwise enter 'no' "))
    (assert (taxLiens  found))
    (assert (liens ?ans))
    
)


/*
* function to continuously ask for tax liens while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt tax liens
*/
(deffunction getAnsTax (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                  
    
      (bind ?ans (ask ?asking)) 
      (bind ?ans (lowcase ?ans))                                      
      (printout t " "crlf)

      (bind ?interpreted (interpretTax ?ans))                         

      (if (= ?interpreted "valid") then                               
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf); prompts the user that their input is invalid

         (printout t "Try Again ! " crlf)
         (printout t " " crlf)
      )
   )

   
)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for tax liens.
* Will return either valid or "not possible" based on the validity of the solution.
*/
(deffunction interpretTax (?response)
   
   (bind ?ans "not possible")
   (if (= (sub-string 1 1 ?response) "y") then
      (bind ?ans valid)

   elif (= (sub-string 1 1 ?response) "n") then 
      (bind ?ans valid)

   else 
      (bind ?ans "not possible")
   )
   (return ?ans)
)


(defrule yesLiens  "scores the borrower's tax liens" 

   (taxLiens found)
   (liens yes)


    =>

    (assert (taxLiensScore 50))
  
)

(defrule noLiens  "scores the borrower's tax liens" 

   (taxLiens found)
   (liens no)


    =>

    (assert (taxLiensScore 100))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's FICO credit score. Look to credit utilization for generalized comments.
*/


(defrule creditScoreBackwards "Rule to Backward-Chain one's FICO credit score "
    
    (need-creditScoreFICO ?)
    =>

    (bind ?ans (getAnsFICO "Enter the borrower's FICO credit score "))
    (assert (creditScoreFICO  found))
    (assert (score ?ans))
    
)



/*
* function to continuously ask for FICO score while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt FICO scores
*/

(deffunction getAnsFICO (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                  
    
      (bind ?ans (ask ?asking))                                       
      (printout t " "crlf)

      (bind ?interpreted (interpretFICO ?ans))                        

      (if (= ?interpreted "valid") then                                
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf)

         (printout t "Try Again ! " crlf)
         (printout t " " crlf)
      )
   )

   (return)
)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for FICO score.
* Will return either valid or "not possible" based on the validity of the solution.
*/

(deffunction interpretFICO (?response)
   

   (bind ?ans "not possible")
   (if (and (integerp ?response) (and (>= ?response 300) (<= ?response 850)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)


(defrule bestScore  "If the borrower's FICO score is above 750, designate a score of 100 for this category" 

   (creditScoreFICO found)
   (score ?X&:(<= 750 ?X))


    =>

    (assert (FICOScore 100))
  
)

(defrule goodScore  "If the borrower's FICO score is between 700 and 750, designate a score of 90 for this category"  

   (creditScoreFICO found)
   (score ?X&:(<= 700 ?X)&:(< ?X 750))


    =>

    (assert (FICOScore 90))
  
)

(defrule okScore  "If the borrower's FICO score is between 650 and 700, designate a score of 80 for this category"  

   (creditScoreFICO found)
   (score ?X&:(<= 650 ?X)&:(< ?X 700))


    =>

    (assert (FICOScore 80))
  
)

(defrule midRangeScore  "If the borrower's FICO score is between 600 and 650, designate a score of 70 for this category"  

   (creditScoreFICO found)
   (score ?X&:(<= 600 ?X)&:(< ?X 650))


    =>

    (assert (FICOScore 70))
  
)

(defrule terribleScore  "If the borrower's FICO score is between 550 and 600, designate a score of 50 for this category"  

   (creditScoreFICO found)
   (score ?X&:(<= 550 ?X)&:(< ?X 600))


    =>

    (assert (FICOScore 50))
  
)

(defrule worstScore  "If the borrower's FICO score is between 300 and 550, designate a score of 10 for this category"  

   (creditScoreFICO found)
   (score ?X&:(<= 300 ?X)&:(< ?X 550))


    =>

    (assert (FICOScore 10))
  
)





/*
* Section to read, interpret, backward chain, and score borrower's FICO health insurance score.
* Look to credit utilization above for generalized comments.
*/


(defrule healthInsuranceScoreBackwards "Rule to Backward-Chain borrower's FICO health insurance score "
    
    (need-healthInsuranceScore ?)
    =>

    (bind ?ans (getAnsInsuranceScore "Enter the borrower's FICO health insurance score"))
    (assert (healthInsuranceScore  found))
    (assert (healthScore ?ans))
    
)


/*
* function to continuously ask for health insurance score while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt the health insurance score from the user.
*/

(deffunction getAnsInsuranceScore (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking))                                       
      (printout t " "crlf)

      (bind ?interpreted (interpretInsuranceScore ?ans))              

      (if (= ?interpreted "valid") then                                
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf); prompts the user that their input is invalid

         (printout t "Try Again ! " crlf)
         (printout t " " crlf)
      )
   )


)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for FICO Health Insurance scores.
* Will return either valid or "not possible" based on the validity of the solution.
*/

(deffunction interpretInsuranceScore (?response)
   
   (bind ?ans "not possible")
   (if (and (integerp ?response) (and (>= ?response 200) (<= ?response 997)) ) then

      (bind ?ans valid)
   )

   (return ?ans)

)



(defrule bestInsuranceScore  "If the borrower's health insurance is 800 or higher, designate a score of 100 in this category"

   (healthInsuranceScore found)
   (healthScore ?X&:(<= 800 ?X))


    =>


    (assert (hScore 100))
  
)

(defrule goodInsuranceScore  "If the borrower's health insurance is between 650 and 800, designate a score of 90 in this category" 

   (healthInsuranceScore found)
   (healthScore ?X&:(<= 650 ?X)&:(< ?X 800))


    =>

    (assert (hScore 90))
  
)

(defrule okInsuranceScore  "If the borrower's health insurance is between 650 and 500, designate a score of 75 in this category" 

   (healthInsuranceScore found)
   (healthScore ?X&:(<= 500 ?X)&:(< ?X 650))


    =>

    (assert (hScore 75))
  
)

(defrule poorInsuranceScore  "If the borrower's health insurance is between 350 and 500, designate a score of 60 in this category" 

   (healthInsuranceScore found)
   (healthScore ?X&:(<= 350 ?X)&:(< ?X 500))


    =>

    (assert (hScore 60))
  
)


(defrule worstInsuranceScore  "If the borrower's health insurance is below 350, designate a score of 30 in this category" 

   (healthInsuranceScore found)
   (healthScore ?X&:(> 350 ?X))


    =>

    (assert (hScore 30))
  
)




/*
* Section to read, interpret, backward chain, and score borrower's auto insurance score. 
* Look to credit utilization for generalized comments.
*/


(defrule autoInsuranceScoreBackwards "Rule to Backward-Chain borrower's FICO Auto insurance score "
    
    (need-autoInsuranceScore ?)
    =>

    (bind ?ans (getAnsAutoScore "Enter the borrower's FICO auto insurance score"))
    (assert (autoInsuranceScore  found))
    (assert (autoScore ?ans))
    
)


/*
* function to continuously ask for auto score while a valid input has not been entered yet. Once entered, the program will 
* return the answer entered given by the user.
* Argument passed through is the question to be asked to prompt the auto score.
*/

(deffunction getAnsAutoScore (?asking)

   (bind ?done FALSE)                                                 
   

   (while (not ?done)                                                 
    
      (bind ?ans (ask ?asking))                                      
      (printout t " "crlf)

      (bind ?interpreted (interpretAutoScore ?ans))                   

      (if (= ?interpreted "valid") then                               
         (bind ?done TRUE)                                            
         (return ?ans)                                                
      else
         (printout t "That's an invalid input for the question!" crlf); prompts the user that their input is invalid

         (printout t "Try Again ! " crlf)
         (printout t " " crlf)
      )
   )

)


/*
* Function used to interpret the answer given by a user to see whether it falls within the possible values for a FICO auto score.
* Will return either valid or "not possible" based on the validity of the solution.
*/

(deffunction interpretAutoScore (?response)
   

   (if (and (integerp ?response) (and (>= ?response 300) (<= ?response 900)) ) then

      (return valid)
   )

   (return "not possible")

)



(defrule bestAutoScore  "If FICO auto score is above 800, designate a score of 100 to this category" 

   (autoInsuranceScore found)
   (autoScore ?X&:(<= 800 ?X))


    =>

    (assert (aScore 100))
  
)

(defrule goodAutoScore  "If FICO auto score is between 700 and 800, designate a score of 90 to this category" 

   (autoInsuranceScore found)
   (autoScore ?X&:(<= 700 ?X)&:(< ?X 800))


    =>

    (assert (aScore 90))
  
)

(defrule okAutoScore  "If FICO auto score is between 600 and 700, designate a score of 80 to this category"  

   (autoInsuranceScore found)
   (autoScore ?X&:(<= 600 ?X)&:(< ?X 700))


    =>

    (assert (aScore 80))
  
)

(defrule poorAutoScore   "If FICO auto score is between 500 and 600, designate a score of 65 to this category"  

   (autoInsuranceScore found)
   (autoScore ?X&:(<= 500 ?X)&:(< ?X 600))


    =>

    (assert (aScore 65))
  
)

(defrule poorAutoScore   "If FICO auto score is between 400 and 500, designate a score of 45 to this category"  

   (autoInsuranceScore found)
   (autoScore ?X&:(<= 400 ?X)&:(< ?X 500))


    =>

    (assert (aScore 45))
  
)


(defrule worstAutoScore  "If FICO auto score is below 400, designate a score of 20 to this category"   

   (autoInsuranceScore found)
   (autoScore ?X&:(> 400 ?X))


    =>

    (assert (aScore 20))
  
)



/*
* Now that all individual category scores have been calculated, the next section will determine the overall scores and print what loans can
* be achieved with the given score.
*/


(defrule calculation "Once each category has been assigned an individual score, the average of the scores will be calculated to 
determine the overall credit score"
  

  (utilizationScore ?a)
  (limitScore ?b)
  (chargeOffScore ?c)
  (bankruptcyScore ?d)
  (collectionsScore ?e)
  (dtiScore ?f)
  (historyScore ?g)
  (newScore ?h)
  (criminalScore ?k)
  (creditMixScore ?m)
  (creditInquiriesScore ?n)
  (incomeScore ?o)
  (educationScore ?p)
  (maritalScore ?q)
  (legalJudgementScore ?r)
  (taxLiensScore ?s)
  (FICOScore ?t)
  (hScore ?u)
  (aScore ?v)
  
  
=>

  /*
  * Calculates the average of all the scores and asserts it in a fact labeled 'average'
  */
  (assert (average (integer (/ (+ ?a ?b ?c ?d ?e ?f ?g ?h ?k ?m ?n ?o ?p ?q ?r ?s ?t ?u ?v) 19)) ))

)





(defrule upperTier "If the final credit score is between 90 and 100, then the score falls into the top category.
In this category, the borrower will unlock the highest tier loans"

   (average ?X&:(<= 90 ?X)&:(<= ?X 100))
  
  =>

  (printout t crlf crlf (str-cat "Congratulations, you're credit score is " ?X " out of a possible 100.") crlf)
  (printout t "This is a top tier credit score and falls into the highest category possible! " crlf)



  /* 
  * Print the available loans for this credit score category
  */

  (printout t crlf crlf "With this credit score, you can access the following loans: " crlf crlf "Mortgages" crlf crlf)
  

  (printout t "Loan to Value ratio (how much of the house you can mortgage): 96%" crlf 
  "30 year fixed mortgage 4.127% apr" crlf  
  "15 year fixed mortgage 3.559% apr" crlf
  "Adjustable rate mortgage starting with 4.885% apr" crlf 
  "30 year jumbo fixed mortgage 3.979% apr" crlf 
  "15 year jumbo fixed mortgage 3.596% apr" crlf
   "Jumbo Adjustable mortgage starting with 4.888% apr" crlf)



   (printout t crlf crlf "Auto Loans" crlf crlf)
   (printout t "60 month new auto loan 4.557% apr" crlf)
   (printout t "48 month new auto loan 4.518% apr" crlf)
   (printout t "36 month new auto loan 4.488% apr" crlf)


   (printout t crlf crlf "Home Equity Loans" crlf crlf)
   (printout t "10 year Home Equity Loan 6.309% apr" crlf)
   (printout t "15 year Home Equity Loan 6.605% apr" crlf)

  
  (printout t crlf crlf "Credit Card Loans" crlf crlf)
  (printout t "Credit Card Loan 12.99% apr" crlf crlf)


)

    



(defrule greatScore "If the final credit score is between 80 and 90, then the score falls into the second category.
In this category, the borrower will unlock the second highest tier loans"

   (average ?X&:(<= 80 ?X)&:(<= ?X 90))
  
  =>

  (printout t crlf crlf (str-cat "Nice, you're credit score is " ?X " out of a possible 100!") crlf)
  (printout t "This is a solid credit score and falls into the second highest category possible! " crlf)



  /* 
  * Print the available loans for this credit score category
  */

  (printout t crlf crlf "With this credit score, you can access the following loans: " crlf crlf "Mortgages" crlf crlf)
  

  (printout t "Loan to Value ratio (how much of the house you can mortgage): 88%" crlf 
  "30 year fixed mortgage 4.349% apr" crlf  
  "15 year fixed mortgage 3.781% apr" crlf
  "Adjustable mortgage starting with 5.107% apr" crlf 
  "30 year jumbo fixed mortgage 3.979% apr" crlf 
  "15 year jumbo fixed mortgage 3.596% apr" crlf
   "Jumbo Adjustable mortgage starting with 5.09% apr" crlf)



    
   (printout t crlf crlf "Auto Loans" crlf crlf)
   (printout t "60 month new auto loan 5.892% apr" crlf)
   (printout t "48 month new auto loan 5.855% apr" crlf)
   (printout t "36 month new auto loan 5.825% apr" crlf)


   (printout t crlf crlf "Home Equity Loans" crlf crlf)
   (printout t "10 year Home Equity Loan 6.859% apr" crlf)
   (printout t "15 year Home Equity Loan 7.155% apr" crlf)

  
   (printout t crlf crlf "Credit Card Loans" crlf crlf)
   (printout t "Credit Card Loan 17.99% apr" crlf crlf)

)
    



(defrule decentScore "If the final credit score is between 70 and 80, then the score falls into the third category.
In this category, the borrower will unlock the third highest tier loans"

   (average ?X&:(<= 70 ?X)&:(<= ?X 80))
  
  =>

  (printout t crlf crlf (str-cat "OK, you're credit score is " ?X "  out of a possible 100.") crlf)
  (printout t "This is a decent credit score and falls into the third highest category possible. " crlf)


  /* 
  * Print the available loans for this credit score category
  */

  (printout t crlf crlf "With this credit score, you can access the following loans: " crlf crlf "Mortgages" crlf crlf)
  

  (printout t "Loan to Value ratio (how much of the house you can mortgage): 80%" crlf 
  "30 year fixed mortgage 4.626% apr" crlf  
  "15 year fixed mortgage 4.08% apr" crlf
  "Adjustable mortgage starting with 5.35% apr" crlf)


   (printout t crlf crlf "Auto Loans" crlf crlf)
   (printout t "60 month new auto loan 8.162% apr" crlf)
   (printout t "48 month new auto loan 8.108% apr" crlf)
   (printout t "36 month new auto loan 8.076% apr" crlf)

   (printout t crlf crlf "Home Equity Loans" crlf crlf)
   (printout t "10 year Home Equity Loan 8.634% " crlf)
   (printout t "15 year Home Equity Loan 8.930% apr" crlf)

  
   (printout t crlf crlf "Credit Card Loans" crlf crlf)
   (printout t "Credit Card Loan 22.99% apr" crlf crlf)

)



(defrule mediocreScore "If the final credit score is between 50 and 70, then the score falls into the fourth category.
In this category, the borrower will unlock the fourth highest tier loans"

   (average ?X&:(<= 50 ?X)&:(<= ?X 70))
  
  =>

  (printout t crlf crlf (str-cat "Mediocre, you're credit score is " ?X "  out of a possible 100.") crlf)
  (printout t "This is a so-so credit score and falls into the fourth highest category possible. " crlf)


  /* 
  * Print the available loans for this credit score category
  */

  (printout t crlf crlf "With this credit score, you can access the following loans: " crlf crlf "Mortgages" crlf crlf)
  

  (printout t "Loan to Value ratio (how much of the house you can mortgage): 72%" crlf 
  "30 year fixed mortgage 5.45% apr" crlf  
  "15 year fixed mortgage 4.86% apr" crlf
  "Adjustable mortgage starting with 6.274" crlf)
    

  (printout t crlf crlf "Auto Loans" crlf crlf)
  (printout t "60 month new auto loan 11.246% apr" crlf)
  (printout t "48 month new auto loan 11.174% apr" crlf)
  (printout t "36 month new auto loan 11.138% apr" crlf crlf)


)

(defrule needsImprovement "If the final credit score is between 30 and 50, then the score falls into the fifth category.
In this category, the borrower will unlock the fifth highest tier loans"

   (average ?X&:(<= 30 ?X)&:(<= ?X 50))
  
  =>

  (printout t (str-cat "You're credit score needs improvement, currently it is " ?X " out of a possible 100.") crlf)
  (printout t "Try to bring your score up, right now it places you in the second to last category " crlf)


  /* 
  * Print the available loans for this credit score category
  */

  (printout t crlf crlf "With this credit score, you can access the following loans: " )

  (printout t crlf crlf "Auto Loans" crlf crlf)
  (printout t "60 month new auto loan 15.926% apr" crlf)
  (printout t "48 month new auto loan 15.852% apr" crlf)
  (printout t "36 month new auto loan 15.81% apr" crlf crlf)
    

)

(defrule dismalScore "If the final credit score is between 0 and 30, then the score falls into the sixth category.
In this category, the borrower will unlock the sixth highest tier loans"

   (average ?X&:(<= 0 ?X)&:(<= ?X 30))
  
  =>

  (printout t (str-cat "You're credit score is " ?X " out of a possible 100.") crlf)
  (printout t (str-cat "Right now you are in the lowest credit score group within the system, at least there's no where to go but up!") crlf)

   /* 
  * Print the available loans for this credit score category
  */
  
  (printout t crlf crlf "With this credit score, you can access the following loans: " )

  (printout t crlf crlf "Payday Loans" crlf crlf)
  (printout t "2 week Payday Loan 400% apr worth around $500 " crlf crlf)


)


(run)

